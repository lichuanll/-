# 目录

[--关于算法与C++](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8Ec) 
  
[----C++简介](https://github.com/lichuanll/-/tree/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC%2B%2B#c%E7%AE%80%E4%BB%8B)
  
[----C++常用头文件](https://github.com/lichuanll/-/tree/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC%2B%2B#c%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6)
  
[----C++简约输入输出](https://github.com/lichuanll/-/tree/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC%2B%2B#c%E7%AE%80%E7%BA%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA)
	
[------输入关键字：cin](https://github.com/lichuanll/-/tree/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC%2B%2B#%E8%BE%93%E5%85%A5%E5%85%B3%E9%94%AE%E5%AD%97cin)

[------输出关键字：cout](https://github.com/lichuanll/-/tree/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC%2B%2B#%E8%BE%93%E5%87%BA%E5%85%B3%E9%94%AE%E5%AD%97cout)

 [------注意事项](https://github.com/lichuanll/-/tree/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC%2B%2B#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9)
 
 [----输入输出拓展](https://github.com/lichuanll/-/tree/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC%2B%2B#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8B%93%E5%B1%95)
 
 [------说明](https://github.com/lichuanll/-/tree/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC%2B%2B#%E8%AF%B4%E6%98%8E)
 
 [------运作流程](https://github.com/lichuanll/-/tree/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC%2B%2B#%E8%BF%90%E4%BD%9C%E6%B5%81%E7%A8%8B)
 
 [------用处](https://github.com/lichuanll/-/tree/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC%2B%2B#%E7%94%A8%E5%A4%84)
 
 [----C++的一些算法工具](https://github.com/lichuanll/-/tree/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC%2B%2B#c%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E5%B7%A5%E5%85%B7)
 
 [------sort](https://github.com/lichuanll/-/tree/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC%2B%2B#sort)
 
 [--------介绍](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#%E4%BB%8B%E7%BB%8D)
 
  [--------普通数组排序](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#%E6%99%AE%E9%80%9A%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F)
  
  [--------对结构体数组进行排序](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#%E5%AF%B9%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F)
  
  [--------关于函数指针的一些拓展](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8B%93%E5%B1%95)
  
  [------二分查找](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE)
  
  [--------介绍](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#%E4%BB%8B%E7%BB%8D-1)
  
  [--------查找元素是否存在](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8)
  
  [--------查找第一个大于等于某个值的元素](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#%E6%9F%A5%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E6%9F%90%E4%B8%AA%E5%80%BC%E7%9A%84%E5%85%83%E7%B4%A0)
  
  [--------查找第一个大于某个值的元素](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#%E6%9F%A5%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%A4%A7%E4%BA%8E%E6%9F%90%E4%B8%AA%E5%80%BC%E7%9A%84%E5%85%83%E7%B4%A0)
  
  [------全排列](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#%E5%85%A8%E6%8E%92%E5%88%97)
  
  [--------介绍](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#%E4%BB%8B%E7%BB%8D-2)
  
  [--------普通数组全排列](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#%E6%99%AE%E9%80%9A%E6%95%B0%E7%BB%84%E5%85%A8%E6%8E%92%E5%88%97)
  
  [--------对结构体数组全排列](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#%E5%AF%B9%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84%E5%85%A8%E6%8E%92%E5%88%97)
  
  [----C++容器](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#c%E5%AE%B9%E5%99%A8)
  
  [------vector](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#vector)
  
  [------stack](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#stack)
  
  [------queue](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#queue)
  
  [------priority_queue](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#priority_queue)
  
  [------关于模板的拓展](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#%E5%85%B3%E4%BA%8E%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%8B%93%E5%B1%95)
  
  [--------函数模板](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF)
  
  [--------类模板](https://github.com/lichuanll/-/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E4%B8%8EC++/README.md#%E7%B1%BB%E6%A8%A1%E6%9D%BF)
# 关于算法与C++
## C++简介
一种面向对象编程的语言（oop），但是在算法中我们不关心面向对象。

好处：

1.对C有很好的向下兼容性，基本是C语法。

2.有很多简便且好用的工具。

严格意义上来说我们学的并不是C++而是C  +  工具。

## C++常用头文件
### #include<iostream>
	#include<iostream>
类比#include<stdio.h>就可以
	
### #include<algorithm>
	#include<algorithm>
常用的算法工具头文件
	
### #include<bits/stdc++.h>
	
devc里有的万能头文件


在头文件后紧接着加入
using namesapce std;
代表使用这个命名空间里的东西。(目前只需要记住就行)
## C++简约输入输出
C++的第一段代码
```c++
#include<isotream>
using namespace std;
int main()
{
    cout << "Hello,World!"<<endl;//endl为C++里的回车
}
```
与下面C的第一段代码相同
```c
#include<stdio.h>
int main()
{
    printf("Hello,World!\n");
}
```
### 输入关键字：cin
方法：cin 右移运算符 你要输入的东西;
```c++
#include<isotream>
using namespace std;
int main()
{
    int a;
    cin >> a;
    int b,c;
    cin >> b >>c;
}
```
### 输出关键字：cout
方法：cout 左移运算符 你要输出的东西；
```c++
#include<isotream>
using namespace std;
int main()
{
    int a;
    cin >> a;
    int b,c;
    cin >> b >>c;
    cout <<a;
    cout <<b<<c;
}
```
当然也可以输出字符与变量，且支持转义字符
```c++
#include<isotream>
using namespace std;
int main()
{
    int a=5;
    cout << "a=" << a <<"\n";
}
```
### 注意事项
由于cin和cout是流输入流输出，在处理大量的数据时，是没有C的scanf与printf快的，

个别题会卡这个时间。(iostream这个头文件也包括C的这两个输入输出函数)
## 输入输出拓展
### 说明
C++这种输入输出是一种流输入(istream包含在fstream这个头文件里)

和流输出(ostream包含在sstream这个头文件里)都被包含在iostream里。

cin是istream的一个对象，cout是ostream的一个对象。这种流被称作IO流。
### 运作流程
cin和cout中使用>>和<<运算符，这两个运算符并不是做了位运算，

这两个运算符在内部经过重载(类似函数重载)，从而可以输入输出。

cin/cout与>>/<<结合在一起就又一次返回一个流输入输出对象cin或

cout从而可以连续出现多个<<或>>。这种编程思想称作链式编程。
![image](https://user-images.githubusercontent.com/109082987/216770351-b14aaa35-dff4-4700-b69c-5a789d7232d7.png)

### 用处
用于读取文件

例如用C++借助glfw库读取一个glsl的shader

vertexshader.glsl
```glsl
#version 330 core
layout (location=0) in vec3 aPos;
layout (location=1) in vec3 aColor;
layout (location=2) in vec2 aUV;
layout (location=3) in vec3 aNormal;
out vec3 outColor;
out vec2 outUV;
out vec3 outNormal;
out vec3 outFragPos;
uniform mat4 _modeMatrix;
uniform mat4 _viewMatrix;
uniform mat4 _projMatrix;

out vec4 _posLightSpace;
uniform mat4 _lightSpaceMat;

void main()
{
    gl_Position = _projMatrix * _viewMatrix * _modeMatrix * vec4(aPos.x,aPos.y,aPos.z,1.0);
    outColor=aColor;
    outUV=aUV;
   
    outNormal=mat3(transpose(inverse(_modeMatrix))) * aNormal;
    _posLightSpace = _lightSpaceMat * _modeMatrix * vec4(aPos,1.0);
    outFragPos=vec3(_modeMatrix * vec4(aPos.x,aPos.y,aPos.z,1.0));
};
```
fragmentshader.glsl
```glsl
#version 330 core
out vec4 FragColor;
in vec3 outColor;
in vec2 outUV;
in vec3 outNormal;
in vec3 outFragPos;
in vec4 _posLightSpace;

uniform sampler2D _shadowMap;
struct Material 
{
    vec3 ambient;

    vec3 diffuse;
    vec3 specular;
    float shininess;
    sampler2D diffusetexture;
   // sampler2D speculartexture;
}; 

uniform Material material;
struct Light
{
  vec3 ambient;
  vec3 diffuse;
  vec3 specular;
  vec3 dirction_lightpos;
  vec3 point_lightpos[5];
  vec3 spot_lightpos;
  int  pointlightcount;
  float constant;
  float linear;
  float quadratic;
  float cutOff;
  float outcutOff;
};
uniform Light light;

//uniform sampler2D ourTexture;
uniform int iftexture;
uniform int ifLight;
uniform int ifusetex;
uniform vec3 Lightcolor;
//uniform vec4 LightPos;
uniform vec3 Lightdirection;
uniform vec3 viewPos;
uniform samplerCube skybox;

float caculateShadow(vec4 _posInLight)
{
    vec3 _posInLightNDC = _posInLight.xyz/_posInLight.w;
    vec3 _uvd = _posInLightNDC * 0.5 + 0.5;
    float _oldDepth = texture(_shadowMap,_uvd.xy).r;
    float _currDepth = _uvd.z;
    return _currDepth > _oldDepth ? 1 : 0;
}
vec3 dirction_light(vec3 norm,Light l,vec3 viewdirect)
{
    vec3 lightDir = normalize(l.dirction_lightpos);
    float diff = max(dot(lightDir,norm),0);
    
    vec3 reflectdir = reflect(-lightDir,norm);
    float _spec = pow(max(dot(viewdirect, reflectdir),0), material.shininess);


    vec3 ambient = l.ambient * material.ambient;
    
    vec3 diffuse = l.diffuse * (diff * material.diffuse);
    if(iftexture==1) 
    diffuse = l.diffuse * diff * vec3(texture(material.diffusetexture, outUV));

    vec3 specular = l.specular * (_spec * material.specular);

    return ambient+(diffuse+specular);// * (caculateShadow(_posLightSpace));
}

vec3 point_light(vec3 norm,Light l,vec3 viewdirct,vec3 fragpos,int i)
{
     vec3 lightDir = normalize(l.point_lightpos[i]-fragpos);
     float distance = length(l.point_lightpos[i]-fragpos);
     float attenuation = 1.0/(l.constant + l.linear * distance + l.quadratic * (distance * distance));
     float diff = max(dot(lightDir,norm),0);
      vec3 reflectdir = reflect(-lightDir,norm); 
     float _spec = pow(max(dot(viewdirct, reflectdir),0), material.shininess);

      vec3 ambient = l.ambient * material.ambient;

      vec3 diffuse = l.diffuse * (diff * material.diffuse);

    if(iftexture==1) 
    diffuse = l.diffuse * diff * vec3(texture(material.diffusetexture, outUV));
    vec3 specular = l.specular * (_spec * material.specular);
    
    vec3 result = ambient+diffuse+specular;
    return result * attenuation;

}

vec3 spot_light(vec3 norm,Light l,vec3 viewdirct,vec3 fragpos)
{
   vec3 lightDir = normalize(l.spot_lightpos-fragpos);
   float theta = dot(lightDir,normalize(-Lightdirection));

   float eplison = l.cutOff - l.outcutOff;

   float intensity = clamp((theta-l.outcutOff)/eplison,0.0,1.0);
   float diff = max(dot(lightDir,norm),0);
   vec3 reflectdir = reflect(-lightDir,norm); 
   float _spec = pow(max(dot(viewdirct, reflectdir),0), material.shininess);

     vec3 ambient = l.ambient * material.ambient;

     vec3 diffuse = l.diffuse * (diff * material.diffuse);

    if(iftexture==1) 
    diffuse = l.diffuse * diff * vec3(texture(material.diffusetexture, outUV));
    vec3 specular = l.specular * (_spec * material.specular);
    
    
       
    vec3 result = ambient;
   
     if(theta > light.outcutOff)
     result += intensity * diffuse +  intensity * specular ;


    return result;
}


void main()
{
   vec3 norm = normalize(outNormal);
 
    
   vec3 viewline=normalize(viewPos-outFragPos);
    float ratio = 1.00 / 1.20;
   vec3 Iray = normalize(outFragPos - viewPos);
   vec3 Rray = refract(Iray,norm,ratio);
   vec4 skyboxcolor = vec4(texture(skybox,Rray).rgb,1.0);
   vec3 output;
   output+=dirction_light(norm,light,viewline);

   /*for(int i=0;i<light.pointlightcount;i++)
    output+=point_light(norm,light,viewline,outFragPos,i);

   output+=spot_light(norm,light,viewline,outFragPos);*/
   if(iftexture==0)
   {
     if(ifusetex==1)
     FragColor = vec4(outColor * output,1.0f) * skyboxcolor;
     else if(ifusetex==0)
     FragColor =  vec4(outColor * output,1.0f);
   }

    if(iftexture==1)
   {
   if(ifusetex==1)
   FragColor = texture(material.diffusetexture,outUV) * vec4(output,1.0f) * skyboxcolor;
   else if(ifusetex==0)
   FragColor =  skyboxcolor; //vec4(outColor,1.0f);

   }
};
```
```c++
initshader("vertexshader.glsl", "fragmentshader.glsl");
```
```c++
void shader::initshader(const char* _vertexPath, const char* _fragPath)
{
	string _vertexCode("");
	string _fragCode("");

	ifstream _vShaderfile;//用来读取文件
	ifstream _fShaderfile;
	_vShaderfile.exceptions(ifstream::failbit | ifstream::badbit);//用来try  catch
	_fShaderfile.exceptions(ifstream::failbit | ifstream::badbit);
	try
	{
		_vShaderfile.open(_vertexPath);//读取进来文件 
		_fShaderfile.open(_fragPath);


		stringstream _vShaderStream, _fShaderStream;//加入数据流
		_vShaderStream << _vShaderfile.rdbuf();//读取文件内容
		_fShaderStream << _fShaderfile.rdbuf();

		_vertexCode = _vShaderStream.str();//获取代码并保存
		_fragCode = _fShaderStream.str();
	}

	catch (ifstream::failure e)
	{
		string errStr = "read shader fail";
		cout << errStr << endl;
	}
/********************************************************/
	const char* _vShaderStr = _vertexCode.c_str();
	const char* _fShaderStr = _fragCode.c_str();

	//shader的编译链接
	unsigned int _vertexID = 0, _fragID = 0;//代表要编译的ID 
	char _infoLog[512];//记录编译链接过程中的BUG
	int _successFlag = 0;

	//编译
	_vertexID = glCreateShader(GL_VERTEX_SHADER);//创建一个shaderID
	glShaderSource(_vertexID, 1, &_vShaderStr, NULL);//告诉当前ID是什么样的代码
	glCompileShader(_vertexID);//开始编译括号里的东西

	glGetShaderiv(_vertexID, GL_COMPILE_STATUS, &_successFlag);//捕捉编译过程会不会出现Bug
	if (!_successFlag)//如果编译不成功
	{
		glGetShaderInfoLog(_vertexID, 512, NULL, _infoLog);//拿到编译错误的原因
		string errStr(_infoLog);//打印错误信息
		cout << _infoLog << endl;
	}
	//以下同上对另一个ID处理
	_fragID = glCreateShader(GL_FRAGMENT_SHADER);
	glShaderSource(_fragID, 1, &_fShaderStr, NULL);
	glCompileShader(_fragID);

	glGetShaderiv(_fragID, GL_COMPILE_STATUS, &_successFlag);
	if (!_successFlag)
	{
		glGetShaderInfoLog(_fragID, 512, NULL, _infoLog);
		string errStr(_infoLog);
		cout << _infoLog << endl;
	}
	//链接
	m_shaderProgram = glCreateProgram();//创建一个shader程序
	glAttachShader(m_shaderProgram, _vertexID);//向程序里面加入编译好的两个shaer的ID   
	glAttachShader(m_shaderProgram, _fragID);
	glLinkProgram(m_shaderProgram);//把加入的程序链接成一个大程序

	glGetProgramiv(m_shaderProgram, GL_LINK_STATUS, &_successFlag);//判断在链接中会不会出错
	if (!_successFlag)
	{
		glGetProgramInfoLog(m_shaderProgram, 512, NULL, _infoLog);//拿到链接过程中程序的错误信息
		string errStr(_infoLog);
		cout << _infoLog << endl;
	}
	glDeleteShader(_vertexID);//由于已经生成程序所以删除两个ID
	glDeleteShader(_fragID);
}
```
## C++的一些算法工具
### sort
还在为冒泡太慢而苦恼吗?

还在为不会写快排而烦躁吗？

今天它来了。
#### 介绍
包含在#include<algorithm>头文件，用于对容器进行排序。

内部大致使用的是快速排序算法，整体时间复杂度O(n*logn)。默认从小到大排序。

sort(第一个参数，第二个参数);

sort(第一个参数，第二个参数，第三个参数);

第一个参数：容器中要排序的第一个元素的地址

第二个参数：容器中要排序的最后一个元素的地址

第三个参数：函数指针，可有可无，对特定的容器排序才用的到。

    注意：对所指定范围的排序，是前闭后开的。sort(a,b)->[a,b) 
    
 #### 普通数组排序
 从小到大排序
 ```c++
 #include<isotream>
#include<algorithm>
using namespace std;
int main()
{
    int a[50]={5,3,4,6,4,2};
    sort(a, a + 6);
    for (int i = 0;i < 6;i++)
        cout << a[i];
}
 ```
 从大到小排序-1
 ```c++
 #include<isotream>
#include<algorithm>
using namespace std;
int main()
{
    int a[50]={5,3,4,6,4,2};
    sort(a, a + 6,greater<int>());
    for (int i = 0;i < 6;i++)
        cout << a[i];
}
 ```
 从大到小排序-2
 ```c++
 #include<isotream>
#include<algorithm>
using namespace std;
bool cmp(int a,int b)
{
    return a>b;//小于号就是从小到大
}
int main()
{
    int a[50]={5,3,4,6,4,2};
    sort(a, a + 6,cmp);
    for (int i = 0;i < 6;i++)
        cout << a[i];
}
 ```
 #### 对结构体数组进行排序
 根据结构体里面的某一个成员对结构体排序
 ```c++
 #include<isotream>
#include<algorithm>
struct Node
{
int value;
int index;
};
bool cp(Node a,Node b)
{
    return a.value<b.value;//大于号就是从小到大排序
}
Node s[20];
int main()
{
	for (int i = 1;i <= 6;i++)
    {
        cin >> s[i].value;
    }
    sort(s + 1, s + 6 + 1, cp);
    for (int i = 1;i <= 6;i++)
    cout << s[i].value;
}
 ```
 #### 关于函数指针的一些拓展
 函数指针：一种变量为函数的指针。
 
其实函数也是一种变量，只不过它不仅有类型(返回值类型)还有参数类型(参数列表中变量的个数和类型)。

函数名相当于一个地址。

函数指针变量的定义
```c++
void (*pFun)(int);//默认指向是一个NULL
//(*pFun)这个括号必须加，否则编译器会认为声明了一个返回值为无类型的指针
```
定义了一个普通函数
```c++
void glFun(int a)//注意返回值类型，与参数列表都相同。
{
    cout << a << endl;
}
```
主函数中
```c++
int main() 
{
     pFun = glFun;
    pFun(2);
    (*pFun)(2);//上下原理相同。
}
```
![image](https://user-images.githubusercontent.com/109082987/216770699-e9b284fe-90d0-4e9e-803b-a12643745c67.png)

也可以定义一个自己创造一个特特定的函数指针类型

```c++
/**
 * @brief 代表一种新类型，不是变量！所以与上述的pFun不一样！
 */
typedef void (*func)(void);
void myfunc(void)
{
    cout << "asda" << endl;
}
int main()
{
     func pfun = myfunc;/*赋值*/
     pfun();/*调用*/
}
```

### 二分查找
#### 介绍
当需要在一段容器中查找某个元素时，一个一个的遍历，没有二分查找快。

    注意：对所指定查找的范围，是前闭后开的。
    
并且二分查找的前提时容器中的元素是有序的
#### 查找元素是否存在
函数：binary_search(首地址，尾地址，查找的元素);

返回值是一个bool，。如果不存在元素返回0。
```c++
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
    int a[]={4,10,11,30,30,69,70,96,100};
    int binary1=binary_search(a,a+9,4);
    cout<<"在数组中查找元素4，结果为："<<binary1<<endl;//查找成功，返回1
    cout <<  a[binary1]<<endl;
    int binary2=binary_search(a,a+9,40);
    cout<<"在数组中查找元素40，结果为："<<binary2<<endl;//查找失败，返回0
}
```
#### 查找第一个大于等于某个值的元素
函数：lower_bound(首地址,尾地址，大于等于的某个值);返回值是所要

查找的一个元素的地址，类型跟容器的类型有关。所以需要用指针来接收。

当需要得到这个元素的位置下标时可以将这个指针与首地址作减法得到的就位置下标。
```c++
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
   int a[] = { 4,10,11,30,30,69,70,96,100 };
   int* lower1 = lower_bound(a, a + 9, 10);
   cout << "在数组中查找第一个大于等于12的元素，结果为：" << *lower1 << endl;
   int lower2 = lower_bound(a, a + 9, 101) - a;//指针之间相减表示的是两个指针所指向内存之间相隔多少个元素
   cout << "在数组中查找第一个大于等于101的元素位置，结果为：" << lower2 << endl;//如果没有返回尾元素
}
```
#### 查找第一个大于某个值的元素
函数：upper_bound(首地址,尾地址，大于等于的某个值);返回值是所要

查找的一个元素的地址，类型跟容器的类型有关。所以需要用指针来接收。

当需要得到这个元素的位置下标时可以将这个指针与首地址作减法得到的就位置下标。
```c++
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
   int a[] = { 4,10,11,30,30,69,70,96,100 };
   int* upper1 = upper_bound(a, a + 9, 10);
    cout << "在数组中查找第一个大于10的元素，结果为：" << *upper1 << endl; 
    int upper2 = upper_bound(a, a + 9, 101) - a;
    cout << "在数组中查找第一个大于101的元素位置，结果为：" << upper2 << endl; 
}
```
### 全排列
#### 介绍
函数next_permutation(容器的首地址，容器的尾地址);

       next_permutation(容器的首地址，容器的尾地址,函数指针);
       
全排列的规则也跟排序一样的道理，跟你所定义的排序规则有关

       注意：对所指定全排列的范围，是前闭后开的。
       
并且全排列的前提是容器中的元素是有序的
#### 普通数组全排列
##### 顺序全排列
```c++
#include <iostream>  
#include <algorithm>  
using namespace std;  
int main()  
{  
    int num[3]={1,2,3};  
    do  
    {  
        cout<<num[0]<<" "<<num[1]<<" "<<num[2]<<endl;  
    }while(next_permutation(num,num+3));  
    return 0;  
}
```
##### 逆序全排列
```c++
#include <iostream>  
#include <algorithm>  
using namespace std;  
bool cmp(int a, int b)
{
    return a > b;
}
int main()  
{  
    int num[3]={1,2,3};  
    sort(num, num + 3, cmp);
    do  
    {  
        cout<<num[0]<<" "<<num[1]<<" "<<num[2]<<endl;  
    }while(next_permutation(num,num+3,cmp));  
    return 0;  
}
```
#### 对结构体数组全排列
```c++
#include<isotream>
#include<algorithm>
struct Node
{
int value;
int index;
};
bool cp(Node a,Node b)
{
    return a.value<b.value;//大于号就是从小到大排序
}
Node s[20];
int main()
{
	for (int i = 1;i <= 6;i++)
    {
        cin >> s[i].value;
    }
    sort(s + 1, s + 6 + 1, cp);
    do  
    {  
       for (int i = 1;i <= 6;i++)
    	{
        	cout << s[i].value << " ";
    	}
        cout <<endl;
    }while(next_permutation(s+1,s+6+1,cp));  
    return 0;  
}
```
## C++容器
### vector
需要包含头文件#include<vector>

vector又名动态数组。可以自动动态扩容。但是耗时。

优点:可以从末尾快速地插入与删除元素,快速的随机访问元素

缺点:在序列中间插入,删除元素较慢,因为需要移动插入或删除位置后面的所有元素.

注意：vector的动态扩展并不是在原有的空间之后后续接新空间，

而是找到更大的内存空间，然后将原数据拷贝新空间，并释放原空间
	
![image](https://user-images.githubusercontent.com/109082987/216770950-b82ed79e-90ef-4626-b4f9-129734d89e98.png)
	
定义一个vector的方法 vector<数据类型>变量名；

常用API：

empty()://判断当前向量容器是否为空

size()://返回当前向量容器中的实际元素个数

[]://返回指定下标的元素

reserve(n)://为当前向量容器预分配n个元素的存储空间

capacity()://返回当前向量容器在重新进行内存分配以前所能容纳的元素个数

resize(n)://调整当前向量容器的大小,使其能容纳n个元素

push_back(item)://在当前向量容器尾部添加一个元素

insert(pos,elem)://在pos位置插入元素elem,即将元素elem插入到迭代器pos指定的元素之前

front()://获取当前向量容器的第一个元素

back()://获取当前向量容器的最后一个元素

erase()://删除当前向量容器中某个迭代器或者迭代器区间指定的元素

clear()://删除当前向量容器中的所有元素

begin()://该函数的两个版本分别返回iterator或者const_iterator,引用容器的第一个元素

end()://该函数的两个版本分别返回iterator或者const_iterator,引用容器的最后一个元素后面的一个位置

rbegin()://该函数的两个版本分别返回reverse_iterator或者const_reverse_iterator,引用容器的最后一个元素

rend()://该函数的两个版本分别返回reverse_iterator或者const_reverse_iterator,引用容器的第一个元素前面的

第一个位置
```c++
#include<iostream>
#include<vector>
using namespace std;
void printvector(vector<int>& v)
{
	for (vector<int>::iterator it = v.begin();it != v.end();it++)
	{
		cout << *it << endl;
	}
	
	
}
//vector的动态扩展并不是在原有的空间之后后续接新空间，而是找到更大的内存空间，然后将原数据拷贝新空间，并释放原空间
//vector的迭代器是支持随机访问的迭代器
//vector<T> v;
//I!采用模板实现类实现，默认构造函数
//vector(v.begin(, v.end());
////将v[begin(), end(3)区间中的元素拷贝给本身。
//vector(n， elem);
// 构造函数将n个elem拷贝给本身。
//vector(const vector & v);
////拷贝构造函数。
void test01()
{
	vector<int>v1;//默认构造，无参构造
	for (int i = 0;i < 10;i++)
	{
		v1.push_back(i);
	}
	printvector(v1);

	vector<int>v2(v1.begin(), v1.end());//通过区间的方式构造
	printvector(v2);

	//n个elem方式构造
	vector<int>v3(10, 100);
	printvector(v3);

	//拷贝构造
	vector<int>v4(v3);
	printvector(v4);
}

//vector的赋值
//vector& operator=(const vector& vec);//重载等号操作符
//assign(beg, end);
////将[beg,end)区间中的数据拷贝赋值给本身。
//assign(n，elem);
//1 / 将n个elem拷贝赋值给本身。
void test02()
{
	vector<int>v1;
	for (int i = 0;i < 10;i++)
	{
		v1.push_back(i);
	}
	printvector(v1);

	vector<int>v2;
	v2 = v1;
	printvector(v2);

	//assign
	vector<int>v3;
	v3.assign(v1.begin(), v1.end());
	printvector(v3);

	//n个elem
	vector<int>v4;

	v4.assign(10,100);
	printvector(v4);

}

//vector容量和大小
//empty();
//!/ 判断容器是否为空
//capacity();I
//!/ 容器的容量
//size();
////返回容器中元素的个数
//resize(int num);
////重新指定容器的长度为num，若容器变长，则以默认值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除。
//resize(int num，elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。
////如果容器变短，则末尾超出容器长度的元素被删除
void test03()
{
	vector<int> v1;
	for (int i = 0;i < 10;i++)
	{
		v1.push_back(i);
	}
	printvector(v1);

	if (v1.empty())
	{
		cout << "空" << endl;
	}

	else if (!v1.empty())
	{
		cout << "不空" << endl;
		cout << "容量为：" << v1.capacity() << endl;
		cout << "v1的大小为" << v1.size() << endl;
	}

	//重新指定大小
	v1.resize(15);
	cout << "容量为：" << v1.capacity() << endl;
	printvector(v1);//如果重新指定的比原来长了，则默认用0填充新的位置
	
	
	v1.resize(15,52);//利用重载版本可以指定默认填充值
	cout << "容量为：" << v1.capacity() << endl;
	printvector(v1);

	v1.resize(5);//如果重新指定短了则会删除多余的元元素
	cout << "容量为：" << v1.capacity() << endl;
	printvector(v1);
}

//vector的插入和删除
//push_back(ele);
//1 / 尾部插入元素ele
//pop_back();
////删除最后一个元素
//insert(const_iterator pos，ele);//迭代器指向位置pos插入元素ele
//insert(const_iterator pos, int count, ele);//迭代器指向位置pos插入count个元素ele
// erase( const_iterator pos ) ;
////删除迭代器指向的元素
//erase(const_iterator start， const_ierator end);//删除迭代器从start到end之间的元素
//clear( );
// 1删除容器中所有元素
void test04()
{
	vector<int>v1;
	//尾插
	v1.push_back(10);
	v1.push_back(20);
	v1.push_back(30);
	v1.push_back(40);
	v1.push_back(50);

	printvector(v1);

	//尾删
	v1.pop_back();
	printvector(v1);
	cout << endl;
	//插入 第一个位置是迭代器
	v1.insert(v1.begin(), 100);
	printvector(v1);
	cout << endl;
	//insert重载版本 插入两个50
	v1.insert(v1.begin(), 2, 50);
	printvector(v1);
	cout << endl;
	//删除
	v1.erase(v1.begin());
	printvector(v1);
	cout << endl;
	//删除的重载版本
	//清空
	v1.erase(v1.begin(), v1.end());
	printvector(v1);
	cout << endl;

	v1.clear();
}

//vector数据存取操作
//at(it idx);
//返回索引idx所指的数据
//operator[];
//返回索引idx所指的数据
//front();
////返回容器中第一个数据元素
//back();
// 返回容器中最后一个数据元素
void test05()
{
	vector<int>v1;
	for (int i = 0;i < 10;i++)
	{
		v1.push_back(i);
	}
	//利用[]
	for (int i = 0;i < v1.size();i++)
	{
		cout << v1[i] <<endl;
	}
	//利用at方式访问
	for (int i = 0;i < v1.size();i++)
	{
		cout << v1.at(i) << endl;
	}
	cout <<"第一个"<< v1.front() << endl;
	cout << "最后一个" << v1.back() << endl;
}

//vector互换容器
//swap(vec);  将vec与本身的元素互换 
void test06()
{
	vector<int>v1;
	cout << "互换前" << endl;
	for (int i = 0;i < 10;i++)
	{
		v1.push_back(i);
	}
	printvector(v1);
	vector<int>v2;
	for (int i = 10;i >=0;i--)
	{
		v2.push_back(i);
	}
	printvector(v2);

	v1.swap(v2);
	cout << "互换后" << endl;
	printvector(v1);
	printvector(v2);


	//巧用swap可以收缩空间
	//vector<int>为匿名对象()为构造函数
	//vector<int>(v3)意思为 将v3的元素通过拷贝构造函数对新定义的匿名对象进行构造函数赋值赋值
	//然后进行swap操作将v3从一开始指向很长的那那块地址变为只想匿名对象地址，匿名对象指向长地址
	//根据匿名对象不会绑定执行完定义匿名对象并进行操作的代码后就自动被释放内存(析构)
	vector<int>v3;
	
	for (int i = 0;i < 100000;i++)
	{
		v3.push_back(i);
	}
	cout << "容量：" << v3.capacity() << endl;
	cout << "大小：" << v3.size() << endl;

	v3.resize(3);
	cout << "重新指定元素大小后的容量：" << v3.capacity() << endl;
	cout << "重新指定元素大小后的大小：" << v3.size() << endl;

	cout << "运用swap后：" << endl;
	vector<int>(v3).swap(v3);
	cout << "容量：" << v3.capacity() << endl;
	cout << "大小：" << v3.size() << endl;

}

//vector预留空间   减少vector在动态扩展时的扩展次数
//reserve(int len)  容器预留位置不初始化，元素不可访问
void test07()
{
	vector<int>v1;

	int num = 0;
	int* p = NULL;
	//统计一共开辟了多少次内存
	for (int i = 0;i < 100000;i++)
	{
		v1.push_back(i);
		if (p != &v1[0])
		{
			p = &v1[0];
			num++;
		}
	}
	cout << num << endl;

	//利用reserve预留空间
	cout << "预留空间后：" << endl;
	num = 0;
	vector<int>v2;
	v2.reserve(100000);
	for (int i = 0;i < 100000;i++)
	{
		v2.push_back(i);
		if (p != &v2[0])
		{
			p = &v2[0];
			num++;
		}
	}
	cout << num << endl;
}

int main()
{
	/*test01();
	test02();
	test03();*/
	//test04();
	//test05();
	//test06();
	test07();
}
```
### stack
栈容器

需要包含头文件#include<stack>

C++栈和数据结构中的栈一样,具有后进先出的特点

stack容器只有一个出口,即栈顶,可以在栈顶插入(进栈)和删除(出栈)元素,

而不允许顺序遍历
	
![image](https://user-images.githubusercontent.com/109082987/216771012-3c7ebf01-598a-47be-abca-be28ca67ba91.png)
	
定义一个stack的方法 ： stack<数据类型>变量名；

常用API

empty()://判断栈容器是否为空

size()://返回栈容器中的实际元素个数

push(elem)://元素elem进栈

top()://返回栈顶元素

pop()://元素出栈
```c++
#include<stack>
using namespace std;
void main(){
    stack<int> st;
    st.push(1);st.push(2);st.push(3);
    cout << st.top() << endl;
    while(!st.empty()){
        cout << st.top() <<endl;
        st.pop();
    }
}
```
### queue

队列容器

需要包含头文件#include<queue>

队列类模板,和数据结构中的队列一样,具有先进先出的特点,queue容器不允许顺序遍历。
	
![image](https://user-images.githubusercontent.com/109082987/216771049-7e570d1b-1498-4804-bcb4-347746816ba2.png)
	
定义一个queue的方法  queue<数据类型>变量名；

常用API

empty()://判断队列容器是否为空

size()://返回队列容器中的实际元素个数

front()://返回队头元素

back()://返回队尾元素

push(elem)://元素elem进队

pop()://元素出队

```c++
#include<queue>
using namespace std;
void main(){
    queue<int> qu;
    qu.push(1);qu.push(2);qu.push(3);
    cout << "队头元素" << qu.front();
    cout << "队尾元素" << qu.back();
    while(!qu.empty()){
        cout << qu.front() << endl;
        qu.pop();
    }
}
```
### priority_queue
优先队列容器

需要包含头文件#include<queue>

优先队列是一种具有受限访问操作的存储结构,元素可以以任意顺序进入

优先队列,一旦元素在优先队列容器中,出队操作将出队列中优先级最高的元素.。

底层靠堆排序实现，默认大顶堆结构。

总结：可以对内部元素在入队的时候自动排序。默认从小到大。

优先队列中优先级的高低由队列中数据元素的关系函数(比较运算符)确定,

用户可以使用默认的关系函数(对于内置数据类型,默认关系函数是值越大优先级越高),

也可以重载自己编写的关系函数
使用方法：

//升序队列

priority_queue <int,vector<int>,greater<int> > q;

//降序队列

priority_queue <int,vector<int>,less<int> >q;

//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现

一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）

元素入队时的过程
	
![image](https://user-images.githubusercontent.com/109082987/216771154-c411cc5e-6936-479d-8b55-68f92fe8b6b3.png)
	
常用API

empty()://判断优先队列容器是否为空

size()://返回优先队列容器中的实际元素个数

push(elem)://元素elem进队

top()://获取队头元素

pop()://元素出队

```c++
#include<queue>
using namespace std;
int main(){
    priority_queue<int> qu;
    qu.push(3);qu.push(1);qu.push(2);
    cout << qu.top() << "队头元素" << endl;
   qu.pop();
}
```
### 关于模板的拓展 
模板分为函数模板和类模板，我们使用的工具大部分为类模板，

模板的作用为我们使用一些函数或者类工具时可以传递任意数据类型的参数。

由于函数模板可以自动类型推导,类模板不可以，所以

函数模板与普通函数在使用时没有什么特别标志(仅在使用时没有任何标志)

但是类模板使用上有明显区别，使用时必须指定类型

指定类型方法，类名后加<数据类型>
#### 函数模板
```c++
#include <iostream>
using namespace std;
template<class T>
void func(T x, T y)
{
    cout << x << " " << y << endl;
}
int main()
{
    int n = 1, m = 2;
    func(n, m);  
    double f = 1.2, g = 2.3;
    func(f, g);  
    return 0;
}
```
#### 类模板
```c++
template <typename T>
struct A
{
	T x;
	T getT(){return x;}
};
int main()
{
    A<int> a;
    a.x=5;
    cout<<a.getT();  
}
```
