# 动态规划
## 简述
### 动态规划与贪心的区别
贪心是从局部最大最小推出整体最大最小，

动态规划是从局部的状态转移到总体的状态，

叫做状态转移，这些状态中有个决策需要哪个状态的过程。

这个过程是与贪心的最大区别。贪心是一个环环相扣的过程，动态规划不一定。

动态规划是一块技巧很多的一块知识！
### 动态规划的本质
用空间换时间，设定每一步的状态，并用空间记录每一步的状态。然后进行状态转移(也叫递推)，

其中动态规划最核心的部分是状态转移方程(也叫递推公式)。
### 如何辨别需要使用动态规划解题
感觉需要枚举脑子难以想象的情况数(状态)，

而且每种情况只有两个选择(决策)，

选择其中一种进入下一种情况(状态转移)。

使用暴力递归时有重复的数据。其中动态规划就是将这些重复过程略去的做法。
### 动态规划的解题步骤
1.设置dp数组，并清楚下标与其下标所对应的值所表示的含义，

一般代表每个阶段中所问的结果

2.初始化dp数组

3.找到状态的递推关系。

4.枚举所有状态，并对所有的状态操作
## 入门例题
### 斐波那契数列
给定一个n，求斐波那契数列的第n项。
```C++
#include<iostream>
using namespace std;
int main()
{
    int n;
    int f[30];//斐波那契数列超过30项会超过32位整型的范围
    cin >> n;
    f[0]=0;
    f[1]=1;
    for(int i=2;i<=n;i++)
    {
            f[i]=f[i-1]+f[i-2];
    }
    cout <<f[n];
}
```
### 爬楼梯
 ![image](https://user-images.githubusercontent.com/109082987/215500749-54b0460d-fa3d-4bbe-b525-b446852da480.png)
 
给定一个n代表有n阶楼梯，一开始在第0阶，每次可以爬1或2个台阶，问共有多少种的方法可以爬到楼顶。

分析：定义一个数组f[50]，数组下标代表楼梯的阶数。

f[0]代表从第0阶到第0的方案数  1

f[1]代表从第0阶到第1阶的方案数 1

f[2]代表从第0阶到第2阶的方案数 2

   ...
   
f[n]代表从第0阶到第n阶的方案数  

f[n]只能从f[n-1]或f[n-2]到达f[n]，所以我们可以得出

f[n]=f[n-1]+f[n-2]
```c++
#include<iostream>
using namespace std;
int main()
{
    int n;
    int f[30];//斐波那契数列超过30项会超过32位整型的范围
    cin >> n;
    f[0]=1;
    f[1]=1;
    for(int i=2;i<=n;i++)
    {
            f[i]=f[i-1]+f[i-2];
    }
    cout <<f[n];
}
```
### 使用最小费用爬楼梯
给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。

一旦你支付此费用，即可选择向上爬一个或者两个台阶。
一共有n阶梯。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯请你计算并返回达到楼梯顶部的最低花费

#测试点：

输入: cost = [1,100,1,1,1,188,1,1,100,1]

输出: 6

分析：定义一个数组f[30]，下标代表楼梯数，数组的值代表到达该下标所需要的花费。

f[n]只能从f[n-1]或f[n-2]到达f[n]，所以我们可以得出

f[n]的最小花费是min(f[n-1]+cost[n-1],f[n-2]+cost[n-2])

```c++
#include<iostream>
using namespace std;
int main()
{
    int n;
    int f[30];//斐波那契数列超过30项会超过32位整型的范围
    int cost[30]={1,100,1,1,1,188,1,1,100,1}//n=10
    cin >> n;
    f[0]=0;
    f[1]=0;
    for(int i=2;i<=n;i++)
    {
            f[i]=min(f[i-1]+cost[i-1],f[i-2]+cost[i-2]);
    }
    cout <<f[n];
}
```
### 数字三角形
从最底部任选一个起点，找到一条到达最顶部的路径。该路径所经过的数字之和最大。

![image](https://user-images.githubusercontent.com/109082987/215502530-1181540d-8cc3-4936-8d02-22d0fd56db79.png)

分析：

最顶端dp[1][1]只能通过dp[2][1]或dp[2][2]到达，所以dp[1][1]的最大值为

dp[1][1]+max(dp[2][1],dp[2][2]);

由此得出dp[i][j]=dp[i][j]+max(dp[i+1][j],dp[i+1][j+1]);

```c++
#include<iostream>
using namespace std;
int main()
{
    int dp[50][50];
    int n;
    cin >> n;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            cin >>dp[i][j];
        }
    }
    for(int i=n-1;i>=1;i--)
    {
        for(int j=1;j<=i;j++)
        {
           dp[i][j]=dp[i][j]+max(dp[i+1][j],dp[i+1][j+1]);
        }
    }
    cout << dp[1][1];
}
```
## 上升子序列问题
有一串数字，找出这一串数字的最大上升子序列的长度是多少。

![image](https://user-images.githubusercontent.com/109082987/215502820-c6e30d5b-1072-46e3-9917-d82807cd4336.png)

分析：设置dp数组，下标i表示第几个数，值代表以该下标数i结尾时最大上升子序列的长度。

以dp[7]结尾时，发现dp[7]与dp[1~6]都可能有关，有关的条件是a[7]>a[1~6]。

在a[1~6]满足条件时，

我们需要求出dp[7]=max(dp[1~6])

注意子序列的最小长度为1。

以dp[i]结尾时，发现dp[i]与dp[1~(i-1)]都可能有关，

有关的条件是a[i]>a[1~(i-1)]。

在a[1~(i-1)]满足条件时，

我们需要求出dp[i]=max(dp[1~(i-1)])

```c++
#include<iostream>
using namespace std;
int a[100];
int dp[100];
int n;
int main()
{
    cin >> n;
    for(int i=1;i<=n;i++)
    cin>>a[i];
    dp[1]=1;

    
    for(int i=2;i<=n;i++)
    {
        int maxn=1;
        for(int j=1;j<i;j++)
        {
            if(a[i]>a[j])
            {
                if(dp[j]+1>maxn)
                maxn=dp[j]+1;
                
            }
        }
        dp[i]=maxn;
    }
	
    //第二种像动态规划套路的版本
    // for(int i=2;i<=n;i++)
    // {
        
    //     for(int j=1;j<i;j++)
    //     {
    //         if(a[i]>a[j])
    //         {
    //             dp[i]=max(dp[i],dp[j]+1);
    //         }
    //     }
    // }
    // cout << dp[n]+1;
    cout << dp[n];
}
```

